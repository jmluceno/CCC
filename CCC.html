<!DOCTYPE html>
<html>
 <head>
  <title>Cabalistic Color Coordinator</title>
  <script src="https://unpkg.com/react@15.3.2/dist/react.js"></script>
  <script src="https://unpkg.com/react-dom@15.3.2/dist/react-dom.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>
  <!--load google fonts-->
	<link href="https://fonts.googleapis.com/css?family=Vesper+Libre" rel="stylesheet">
  <style>
	@font-face {
    font-family: 'Astrological';
    src:url('fonts/Astrological.ttf.woff') format('woff'),
    url('fonts/Astrological.ttf.svg#Astrological') format('svg'),
    url('fonts/Astrological.ttf.eot'),
    url('fonts/Astrological.ttf.eot?#iefix') format('embedded-opentype'); 
    font-weight: normal;
    font-style: normal;
	}
	
</style>

  <script src="js/data.js"></script>
   <style>
    #container {
      background-color: #FFF;
	  font-family: "Vesper Libre";
	  line-height: 1.2;
	  width: 400;
    }
	
  </style>
  

</head>
<body>
	<div id="container"></div>
	<script type="text/babel">
		
		
		var App = React.createClass({
			getInitialState: function() {
				return {
					symbol: "Cabalistic Color Coordinator"
				};
			},
			changeSymbol: function(value) {
				this.setState({
					symbol: value,
					bkgdClr: "#fff"
				});
				var ctx = this.refs.appCanvas.getContext('2d');				 
				ctx.fillStyle = "#FFF";
				ctx.fillRect(0,12, 500, 745);
			},
			
			changeBackground: function(colorData) {			
				var ctx = this.refs.appCanvas.getContext('2d');				 
				ctx.fillStyle = colorData.c;
				ctx.fillRect(0,12, 500, 745);
				if (colorData.quartered && colorData.flecked) {
					this.quarterIt(colorData.quartered);
					this.fleckIt(colorData.flecked);
				} else if (colorData.quartered) {
					this.quarterIt(colorData.quartered);
				} else if (colorData.flecked) {
					this.fleckIt(colorData.flecked);
				} else if (colorData.prismatic) {
					this.prismaticIt(colorData.prismatic);
				} else if (colorData.rayed) {
					this.rayIt(colorData.rayed);
				} else if (colorData.merging) {
					this.mergeIt(colorData.merging);
				}
			},
			
			quarterIt: function(quarterColors) {
				var ctx = this.refs.appCanvas.getContext('2d');
				ctx.fillStyle = quarterColors[0];
				ctx.fillRect(0,12, 250, 410);
				ctx.fillStyle = quarterColors[1];
				ctx.fillRect(250,12, 500, 400);
				ctx.fillStyle = quarterColors[2];
				ctx.fillRect(0,410, 250, 745);
				ctx.fillStyle = quarterColors[3];
				ctx.fillRect(250,410, 500, 745);				
			}, 
			
			mergeIt: function(mergingColors) {
				var ctx = this.refs.appCanvas.getContext('2d');
				var grd=ctx.createLinearGradient(0,250,500,250);
				grd.addColorStop(0,mergingColors[0]);
				grd.addColorStop(1,mergingColors[1]);

				ctx.fillStyle=grd;
				ctx.fillRect(0,12, 500, 745);
			},
			
			fleckIt: function(fleckColor) { //written by Scott Wilde
				var ctx = this.refs.appCanvas.getContext('2d');
				var flecks = [];
				var maxAngle = (Math.PI*2)/3.9;
				var minAngle = (Math.PI*2)/6.9;
				var maxRadius = 1.5;
				var minRadius = 1;

				//draw 500 flecks at 500 random points in the box
				for (var i = 0; i < 5000; i++) {

					// create the fleck and assign center point
					var fleck = {
						x: Math.random() * 500,
						y: Math.random() * 745,
						points: []
					};
					flecks.push(fleck);

					// create the points
					var angleOffset = Math.random() * (Math.PI*2);
					var angle = 0;

					// go until we've completed a circle
					while (angle < (Math.PI*2)) {
						var radius = Math.random() * (maxRadius - minRadius) + minRadius;
						var point = {
							x: Math.cos(angleOffset + angle) * radius,
							y: Math.sin(angleOffset + angle) * radius
						};
						fleck.points.push(point);

						angle += Math.random() * (maxAngle - minAngle) + minAngle;
					}
				}

				flecks.forEach(fleck => {
					var colorIndex = Math.floor(Math.random() * (fleckColor.length));
					ctx.beginPath();
					ctx.moveTo(fleck.points[0].x + fleck.x, fleck.points[0].y + fleck.y);
					for (var j = 1; j < fleck.points.length; j++) {
						var point = fleck.points[j];
						ctx.lineTo(point.x + fleck.x, point.y + fleck.y);
					}
					ctx.closePath();
					ctx.fillStyle = fleckColor[colorIndex];
					ctx.fill();
				});
			}, //end fleckIt
			
			rayIt: function(rayColor) {//written by Scott Wilde
				
				var ctx = this.refs.appCanvas.getContext('2d');
				var center = {x:250, y: 410};
				var rayCount = 12;
				var arcLength = ((Math.PI * 2) / rayCount) * (1/3);
				var radius = Math.max(this.refs.appCanvas.width, this.refs.appCanvas.height);
				ctx.beginPath();
				ctx.moveTo(center.x, center.y);
				for (var j = 0; j < rayCount; j++) {
					var a0 = ((Math.PI * 2) / rayCount) * j - arcLength / 2;
					var a1 = a0 + arcLength;
					var x0 = Math.cos(a0) * radius + center.x;
					var y0 = Math.sin(a0) * radius + center.y;
					var x1 = Math.cos(a1) * radius + center.x;
					var y1 = Math.sin(a1) * radius + center.y;
					ctx.lineTo(x0, y0);
					ctx.lineTo(x1, y1);
					ctx.lineTo(center.x, center.y);
				}
				ctx.closePath();

				ctx.fillStyle = rayColor;
				ctx.fill();
				
			},
			
			prismaticIt: function(prismaticColors) {
				var ctx = this.refs.appCanvas.getContext('2d');
				var radius = 430;
				if (prismaticColors.length == 7) {
					var decrease = 60;
				} else {
					var decrease = 80;
				}
				for (var i = prismaticColors.length - 1; i > -1; i--) {
					ctx.beginPath();
					ctx.arc(250, 410,radius,0,2*Math.PI);
					ctx.fillStyle = prismaticColors[i];
					ctx.fill();
					radius -= decrease;
				}
				
			},
			
			render: function() {
				var containerStyle = {
					maxHeight:200,
					position: "relative",
					width: 500,
					margin: "0 auto 0 auto"

				};				
				var appStyle = {
					width: 500,
					border: "5px solid black",
					borderRadius: 20,
					position: "absolute",
					top: 0,
					left: -5
				};												
				return(
					<div style={containerStyle}>
						<canvas ref="appCanvas" height={757} width={500} />
						<div style={appStyle}>		
							<Output symbol={this.state.symbol} backgroundHandler={this.changeBackground}/>
							<Input inputHandler={this.changeSymbol}/>
						</div>
					</div>
				);
			}
		});
		
		var Output = React.createClass({			
			
			render: function() {
				var outputStyle = {
					height: 300, 
					width: "100%"
					
				};
				return(
					<div style={outputStyle}>
						<TitleBox symbol={this.props.symbol}/>
						<ColorBoxParent symbol={this.props.symbol} backgroundHandler={this.props.backgroundHandler}/>
					</div>
				);
			}
		});
		
		var TitleBox = React.createClass({
			render: function() {
				var titleBoxStyle = {
					width: "100%",
					backgroundColor: "#000",
					color: "#FFF",
					textAlign: "center",
					fontSize: 28,
					paddingTop: 15,
					paddingBottom: 15,
					textTransform: "uppercase",
					borderTopRightRadius: 10,
					borderTopLeftRadius: 10
				};
				return (<div style={titleBoxStyle}>{this.props.symbol}</div>);
			}
		});
		
		
		
		var ColorBoxParent = React.createClass({
			render: function() {
				var symbol = this.props.symbol;
				var backgroundHandler = this.props.backgroundHandler;
				var colorBoxParentStyle = {
					width: "100%",
					paddingLeft: 18,
					paddingTop: 10
				}
				var boxes = data[symbol].map(function(colorDataObject){
					return(<ColorBox data={colorDataObject} backgroundHandler={backgroundHandler}/>);
				});
				return (
					<div style={colorBoxParentStyle}>{boxes}</div>
				);
			}
		});
		
		var ColorBox = React.createClass({			
			render: function() {
				var colorDataObject = this.props.data;
				var backgroundHandler = this.props.backgroundHandler;
				var canvasBox;
				var colorBoxStyle = {
					width: 100,
					float: "left",
					marginRight: 20,
				}
				return (
					<div style={colorBoxStyle}>
						<ScaleName name={colorDataObject.scale}/>
						<MakeCanvasBox colorData={colorDataObject} backgroundHandler={backgroundHandler}/>
						<ColorName name={colorDataObject.colorName}/>
					</div>
				);
			}
		});		
		
		var ScaleName = React.createClass({
			render: function() {
				var boxStyle = {
					width: 100,
					textAlign: "center",
					fontSize: 18,
					textTransform: "uppercase"
				};
				return (
					<div style={boxStyle}>
						{this.props.name}
					</div>
				);
			}
		});
		
		var MakeCanvasBox = React.createClass({
			componentDidMount: function () {
				this.updateCanvas(this.props.colorData);
				return true;
			},
			componentDidUpdate: function () {
				this.updateCanvas(this.props.colorData);
			},
			updateCanvas: function(colorData) {
				var ctx = this.refs.canvas.getContext('2d');
				ctx.fillStyle = colorData.c;
				ctx.fillRect(0,0, 100, 100);
				if (colorData.quartered && colorData.flecked) {
					this.quarterIt(colorData.quartered);
					this.fleckIt(colorData.flecked);
				} else if (colorData.quartered) {
					this.quarterIt(colorData.quartered);
				} else if (colorData.flecked) {
					this.fleckIt(colorData.flecked);
				} else if (colorData.prismatic) {
					this.prismaticIt(colorData.prismatic);
				} else if (colorData.rayed) {
					this.rayIt(colorData.rayed);
				} else if (colorData.merging) {
					this.mergeIt(colorData.merging);
				}
			},
			
			quarterIt: function(quarterColors) {
				var ctx = this.refs.canvas.getContext('2d');
				ctx.fillStyle = quarterColors[0];
				ctx.fillRect(0,0, 50, 50);
				ctx.fillStyle = quarterColors[1];
				ctx.fillRect(50,0, 50, 50);
				ctx.fillStyle = quarterColors[2];
				ctx.fillRect(0,50, 50, 50);
				ctx.fillStyle = quarterColors[3];
				ctx.fillRect(50,50, 50, 50);				
			}, 
			
			mergeIt: function(mergingColors) {
				var ctx = this.refs.canvas.getContext('2d');
				var grd=ctx.createLinearGradient(0,50,100,50);
				grd.addColorStop(0,mergingColors[0]);
				grd.addColorStop(1,mergingColors[1]);

				ctx.fillStyle=grd;
				ctx.fillRect(0,0,100,100);
			},
			
			fleckIt: function(fleckColor) { //written by Scott Wilde
				var ctx = this.refs.canvas.getContext('2d');
				var flecks = [];
				var maxAngle = (Math.PI*2)/3.9;
				var minAngle = (Math.PI*2)/6.9;
				var maxRadius = 1.5;
				var minRadius = 1;

				//draw 200 pink flecks at 200 random points in the box
				for (var i = 0; i < 200; i++) {

					// create the fleck and assign center point
					var fleck = {
						x: Math.random() * 100,
						y: Math.random() * 100,
						points: []
					};
					flecks.push(fleck);

					// create the points
					var angleOffset = Math.random() * (Math.PI*2);
					var angle = 0;

					// go until we've completed a circle
					while (angle < (Math.PI*2)) {
						var radius = Math.random() * (maxRadius - minRadius) + minRadius;
						var point = {
							x: Math.cos(angleOffset + angle) * radius,
							y: Math.sin(angleOffset + angle) * radius
						};
						fleck.points.push(point);

						angle += Math.random() * (maxAngle - minAngle) + minAngle;
					}
				}

				flecks.forEach(fleck => {
					var colorIndex = Math.floor(Math.random() * (fleckColor.length));
					ctx.beginPath();
					ctx.moveTo(fleck.points[0].x + fleck.x, fleck.points[0].y + fleck.y);
					for (var j = 1; j < fleck.points.length; j++) {
						var point = fleck.points[j];
						ctx.lineTo(point.x + fleck.x, point.y + fleck.y);
					}
					ctx.closePath();
					ctx.fillStyle = fleckColor[colorIndex];
					ctx.fill();
				});
			}, //end fleckIt
			
			rayIt: function(rayColor) {//written by Scott Wilde
				
				var ctx = this.refs.canvas.getContext('2d');
				var center = {x:this.refs.canvas.width/2, y: this.refs.canvas.height/2};
				var rayCount = 12;
				var arcLength = ((Math.PI * 2) / rayCount) * (1/3);
				var radius = Math.max(this.refs.canvas.width, this.refs.canvas.height);
				ctx.beginPath();
				ctx.moveTo(center.x, center.y);
				for (var j = 0; j < rayCount; j++) {
					var a0 = ((Math.PI * 2) / rayCount) * j - arcLength / 2;
					var a1 = a0 + arcLength;
					var x0 = Math.cos(a0) * radius + center.x;
					var y0 = Math.sin(a0) * radius + center.y;
					var x1 = Math.cos(a1) * radius + center.x;
					var y1 = Math.sin(a1) * radius + center.y;
					ctx.lineTo(x0, y0);
					ctx.lineTo(x1, y1);
					ctx.lineTo(center.x, center.y);
				}
				ctx.closePath();

				ctx.fillStyle = rayColor;
				ctx.fill();
				
			},
			
			prismaticIt: function(prismaticColors) {
				var ctx = this.refs.canvas.getContext('2d');
				var radius = 70;
				if (prismaticColors.length == 7) {
					var decrease = 10;
				} else {
					var decrease = 11.63;
				}
				for (var i = prismaticColors.length - 1; i > -1; i--) {
					ctx.beginPath();
					ctx.arc(50,50,radius,0,2*Math.PI);
					ctx.fillStyle = prismaticColors[i];
					ctx.fill();
					radius -= decrease;
				}
				
			},
			 				
			render: function() {
				var backgroundHandler = this.props.backgroundHandler;
				var colorData = this.props.colorData;
				
				var boxStyle = {
					width: 100,
					height: 100,
					border: "2px solid black",
					marginBottom: 10
				};
				
				return (
					<div style={boxStyle}>
						<canvas ref="canvas" width={100} height={100} onClick={() => backgroundHandler(colorData)}/>
					</div>
				);
			}
		});
		
		var ColorName = React.createClass({
			render: function() {
				var boxStyle = {
					width: 100,
					textAlign: "center",
					fontSize: 16
				};
				return (
					<div style={boxStyle}>
						{this.props.name}
					</div>
				);
			}
		});
		
		var Input = React.createClass({
			render() {
				var inputStyle = {
					float: "none",
					margin: 10
				};
				
				var titleStyle = {
					textAlign: "center",
					fontSize: 20,
					textTransform: "uppercase"

				};
				
				var buttonStyle = {
					height: 50,
					width: 50,
					fontSize: 20,
					textAlign: "center",
					fontFamily: "Astrological",
					marginRight: 10,
					marginBottom: 10
				};
				return (
					<div style={inputStyle}>
							<div style={titleStyle}>Spheres</div>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of the Premum Mobile")}>9</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of the Fixed Stars")}>8</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Saturn")}>6</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Daath")}>7</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Jupiter")}>5</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Mars")}>4</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of the Sun")}>}</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Venus")}>2</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Mercury")}>1</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of Luna")}>~</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sphere of the Elements")}>y</button>
							<div style={titleStyle}>Elements</div>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Air")}>q</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Water")}>w</button>							
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Fire")}>e</button>
							<div style={titleStyle}>Paths</div>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Mercury")}>1</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Luna")}>~</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Venus")}>2</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Aries")}>!</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Taurus")}>=</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Gemini")}>#</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Cancer")}>$</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Leo")}>%</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Virgo")}>^</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Jupiter")}>5</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Libra")}>&</button>							
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Scorpio")}>*</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sagittarius")}>(</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Capricorn")}>)</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Mars")}>4</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Aquarius")}>_</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Pisces")}>+</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Sol")}>}</button>							
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Saturn")}>6</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Spirit")}>t</button>
								<button style={buttonStyle} onClick={() => this.props.inputHandler("Earth")}>y</button>
						</div>
				);
			}
		});
		
		var destination = document.querySelector("#container");
		ReactDOM.render(
		  <App/>,
		  destination
		);
	</script>
</body>
</html>
